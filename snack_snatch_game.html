<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="assets/favicon.png" type="image/png">
    <title>Snack Snatch - Penguin Stealth Mission</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #0a0a2e, #16213e, #1a237e);
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
        }

        .game-title {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            font-weight: 900;
            color: #00bcd4;
            text-shadow: 0 0 20px rgba(0, 188, 212, 0.5);
            margin-bottom: 10px;
        }

        .game-subtitle {
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            color: #90caf9;
            margin-bottom: 15px;
        }

        .character-selector {
            background: rgba(26, 35, 126, 0.8);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 600px;
        }

        .character-selector h3 {
            color: #00bcd4;
            margin-bottom: 15px;
            text-align: center;
            font-size: clamp(1rem, 3vw, 1.2rem);
        }

        .character-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .character-btn {
            background: rgba(55, 71, 79, 0.8);
            border: 2px solid #37474f;
            padding: 15px 10px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            font-family: 'Orbitron', monospace;
            color: #fff;
        }

        .character-btn:hover {
            border-color: #00bcd4;
            background: rgba(0, 188, 212, 0.2);
            transform: translateY(-2px);
        }

        .character-btn.selected {
            border-color: #00bcd4;
            background: rgba(0, 188, 212, 0.3);
            box-shadow: 0 0 15px rgba(0, 188, 212, 0.4);
        }

        .character-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        .character-name {
            font-size: 0.9rem;
            font-weight: bold;
        }

        .stats-bar {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: rgba(26, 35, 126, 0.8);
            padding: 10px 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
        }

        .stat-label {
            font-size: 0.8rem;
            color: #90caf9;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00bcd4;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 1200px;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(8, min(50px, 10vw));
            grid-template-rows: repeat(8, min(50px, 10vw));
            gap: 2px;
            background: #1a237e;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 188, 212, 0.3);
        }

        .tile {
            width: min(50px, 10vw);
            height: min(50px, 10vw);
            background: #263238;
            border: 1px solid #37474f;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(16px, 4vw, 24px);
            position: relative;
            transition: all 0.2s ease;
        }

        .tile.obstacle {
            background: #4a5568;
            border-color: #2d3748;
        }

        .tile.detected {
            background: rgba(244, 67, 54, 0.3);
            border-color: #f44336;
            animation: pulse 0.5s infinite alternate;
        }

        .tile.vision {
            border-color: rgba(255, 193, 7, 0.8);
            animation: visionPulse 1s infinite alternate;
        }

        @keyframes pulse {
            from { box-shadow: 0 0 5px rgba(244, 67, 54, 0.5); }
            to { box-shadow: 0 0 15px rgba(244, 67, 54, 0.8); }
        }

        @keyframes visionPulse {
            from { 
                background: rgba(255, 100, 100, 0.2);
                box-shadow: 0 0 5px rgba(255, 100, 100, 0.3);
            }
            to { 
                background: rgba(255, 150, 150, 0.3);
                box-shadow: 0 0 10px rgba(255, 150, 150, 0.5);
            }
        }

        .game-info {
            background: rgba(26, 35, 126, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            min-width: 280px;
            flex: 1;
            max-width: 350px;
        }

        .status {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
        }

        .status.playing {
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid #4caf50;
        }

        .status.caught {
            background: rgba(244, 67, 54, 0.3);
            border: 1px solid #f44336;
            animation: shake 0.5s ease-in-out;
        }

        .status.won {
            background: rgba(255, 193, 7, 0.3);
            border: 1px solid #ffc107;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .controls {
            margin-bottom: 15px;
        }

        .controls h3 {
            color: #00bcd4;
            margin-bottom: 10px;
            font-size: clamp(1rem, 3vw, 1.1rem);
        }

        .controls p {
            font-size: clamp(0.8rem, 2vw, 0.9rem);
            line-height: 1.4;
            color: #90caf9;
        }

        .level-info {
            margin-bottom: 15px;
        }

        .level-info h3 {
            color: #00bcd4;
            margin-bottom: 5px;
            font-size: clamp(1rem, 3vw, 1.1rem);
        }

        .button-row {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(45deg, #00bcd4, #0097a7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            flex: 1;
            min-width: 80px;
        }

        button:hover {
            background: linear-gradient(45deg, #0097a7, #00838f);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 188, 212, 0.4);
        }

        button:disabled {
            background: linear-gradient(45deg, #555, #666);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .legend {
            margin-top: 15px;
            font-size: clamp(0.75rem, 2vw, 0.85rem);
        }

        .legend h4 {
            color: #00bcd4;
            margin-bottom: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
            color: #90caf9;
        }

        .mobile-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
            max-width: 250px;
            width: 100%;
        }

        .mobile-btn {
            padding: 12px;
            font-size: clamp(16px, 4vw, 18px);
            min-height: 50px;
        }

        .mobile-btn.empty {
            visibility: hidden;
        }

        .audio-controls {
            margin-bottom: 15px;
            text-align: center;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .volume-slider {
            flex: 1;
            height: 4px;
            background: #37474f;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #00bcd4;
            border-radius: 50%;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: grid;
            }
            
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .game-info {
                width: 100%;
                max-width: none;
            }
            
            .stats-bar {
                gap: 15px;
            }
            
            .stat-item {
                padding: 8px 15px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .character-options {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .character-btn {
                padding: 10px 5px;
            }
            
            .character-icon {
                font-size: 1.5rem;
            }
            
            .stats-bar {
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1 class="game-title">üêß SNACK SNATCH</h1>
        <p class="game-subtitle">Classified Penguin Operation: Steal the fish without being caught!</p>
    </div>

    <div class="character-selector">
        <h3>Choose Your Penguin Agent</h3>
        <div class="character-options">
            <div class="character-btn selected" data-character="skipper">
                <div class="character-icon">üêß</div>
                <div class="character-name">Skipper</div>
            </div>
            <div class="character-btn" data-character="kowalski">
                <div class="character-icon">ü§ì</div>
                <div class="character-name">Kowalski</div>
            </div>
            <div class="character-btn" data-character="rico">
                <div class="character-icon">üí•</div>
                <div class="character-name">Rico</div>
            </div>
            <div class="character-btn" data-character="private">
                <div class="character-icon">üòä</div>
                <div class="character-name">Private</div>
            </div>
        </div>
    </div>

    <div class="stats-bar">
        <div class="stat-item">
            <div class="stat-label">Current Level</div>
            <div class="stat-value" id="currentLevel">1</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Fish Collected</div>
            <div class="stat-value" id="fishCount">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Success Rate</div>
            <div class="stat-value" id="successRate">0%</div>
        </div>
    </div>

    <div class="game-container">
        <div class="game-board" id="gameBoard"></div>
        
        <div class="game-info">
            <div class="status playing" id="gameStatus">Mission Active</div>
            
            <div class="level-info">
                <h3>Level <span id="levelDisplay">1</span></h3>
                <p>Objective: Reach the fish! üêü</p>
            </div>

            <div class="audio-controls">
                <h3>üîä Audio Controls</h3>
                <button id="muteBtn" onclick="toggleMute()">üîá Mute</button>
                <div class="volume-control">
                    <span>üîâ</span>
                    <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="30">
                    <span>üîä</span>
                </div>
            </div>
            
            <div class="controls">
                <h3>Controls:</h3>
                <p>Use WASD to move your penguin around the grid. Avoid the red vision cones of the guards!</p>
            </div>
            
            <div class="button-row">
                <button onclick="resetLevel()">üîÑ Reset</button>
                <button onclick="previousLevel()" id="prevBtn">‚¨ÖÔ∏è Previous</button>
                <button onclick="nextLevel()" id="nextBtn">‚û°Ô∏è Next</button>
            </div>
            
            <div class="legend">
                <h4>Legend:</h4>
                <div class="legend-item">
                    <span id="playerIcon">üêß</span>
                    <span>Your Penguin</span>
                </div>
                <div class="legend-item">
                    <span>üëÆ</span>
                    <span>Security Guard</span>
                </div>
                <div class="legend-item">
                    <span>üêü</span>
                    <span>Fish Snack (Goal)</span>
                </div>
                <div class="legend-item">
                    <span>üì¶</span>
                    <span>Obstacle/Cover</span>
                </div>
                <div class="legend-item">
                    <span style="background: rgba(255, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;">Red</span>
                    <span>Guard Vision</span>
                </div>
            </div>
        </div>
    </div>

    <div class="mobile-controls">
        <div class="mobile-btn empty"></div>
        <button class="mobile-btn" onclick="movePlayer(0, -1)">‚Üë</button>
        <div class="mobile-btn empty"></div>
        <button class="mobile-btn" onclick="movePlayer(-1, 0)">‚Üê</button>
        <button class="mobile-btn" onclick="movePlayer(0, 0)">‚è∏</button>
        <button class="mobile-btn" onclick="movePlayer(1, 0)">‚Üí</button>
        <div class="mobile-btn empty"></div>
        <button class="mobile-btn" onclick="movePlayer(0, 1)">‚Üì</button>
        <div class="mobile-btn empty"></div>
    </div>

    <script>
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.isMuted = false;
                this.volume = 0.3;
                this.initAudio();
            }
            
            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.value = this.volume;
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
            
            async resumeAudio() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }
            
            playTone(frequency, duration, type = 'sine') {
                if (!this.audioContext || this.isMuted) return;
                
                this.resumeAudio();
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            playMove() {
                this.playTone(400, 0.1, 'square');
            }
            
            playDetected() {
                this.playTone(200, 0.5, 'sawtooth');
                setTimeout(() => this.playTone(180, 0.5, 'sawtooth'), 200);
            }
            
            playWin() {
                this.playTone(523, 0.2, 'sine'); // C
                setTimeout(() => this.playTone(659, 0.2, 'sine'), 200); // E
                setTimeout(() => this.playTone(784, 0.3, 'sine'), 400); // G
            }
            
            setVolume(volume) {
                this.volume = volume;
                if (this.masterGain) {
                    this.masterGain.gain.value = this.isMuted ? 0 : volume;
                }
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.masterGain) {
                    this.masterGain.gain.value = this.isMuted ? 0 : this.volume;
                }
                return this.isMuted;
            }
        }

        class SnackSnatchGame {
            constructor() {
                this.gridSize = 8;
                this.currentLevel = 1;
                this.gameState = 'playing';
                this.selectedCharacter = 'skipper';
                this.fishCollected = 0;
                this.totalAttempts = 0;
                
                this.audioManager = new AudioManager();
                
                this.player = { x: 0, y: 7 };
                this.goal = { x: 7, y: 0 };
                this.guards = [];
                this.obstacles = [];
                this.visionColors = [];
                
                this.characterIcons = {
                    skipper: 'üêß',
                    kowalski: 'ü§ì',
                    rico: 'üí•',
                    private: 'üòä'
                };
                
                // All levels now use level 4 difficulty
                this.levels = [
                    {
                        guards: [
                            { x: 1, y: 1, direction: 0, patrol: [0, 1, 2, 3] },
                            { x: 6, y: 6, direction: 2, patrol: [2, 3, 0, 1] },
                            { x: 4, y: 4, direction: 1, patrol: [1, 3] },
                        ],
                        obstacles: [
                            { x: 3, y: 3 }, { x: 2, y: 5 }, { x: 5, y: 1 }, { x: 0, y: 3 }, { x: 7, y: 4 }
                        ]
                    },
                    {
                        guards: [
                            { x: 2, y: 1, direction: 1, patrol: [1, 2, 3, 0] },
                            { x: 5, y: 3, direction: 3, patrol: [3, 0, 1, 2] },
                            { x: 1, y: 6, direction: 0, patrol: [0, 1, 2, 3] },
                        ],
                        obstacles: [
                            { x: 3, y: 2 }, { x: 4, y: 4 }, { x: 6, y: 1 }, { x: 1, y: 4 }, { x: 6, y: 6 }
                        ]
                    },
                    {
                        guards: [
                            { x: 3, y: 2, direction: 2, patrol: [2, 3, 0, 1] },
                            { x: 5, y: 5, direction: 0, patrol: [0, 1, 2, 3] },
                            { x: 2, y: 6, direction: 1, patrol: [1, 3, 2, 0] },
                        ],
                        obstacles: [
                            { x: 1, y: 1 }, { x: 6, y: 2 }, { x: 4, y: 4 }, { x: 0, y: 5 }, { x: 7, y: 6 }
                        ]
                    },
                    {
                        guards: [
                            { x: 1, y: 2, direction: 1, patrol: [1, 2, 3, 0] },
                            { x: 4, y: 1, direction: 2, patrol: [2, 3, 0, 1] },
                            { x: 6, y: 4, direction: 3, patrol: [3, 0, 1, 2] },
                        ],
                        obstacles: [
                            { x: 2, y: 3 }, { x: 5, y: 2 }, { x: 3, y: 5 }, { x: 0, y: 6 }, { x: 7, y: 3 }
                        ]
                    }
                ];
                
                this.directions = [
                    { x: 0, y: -1 }, // up
                    { x: 1, y: 0 },  // right
                    { x: 0, y: 1 },  // down
                    { x: -1, y: 0 }  // left
                ];
                
                this.initializeLevel();
                this.setupEventListeners();
                this.render();
                this.startGameLoop();
                this.updateStats();
            }
            
            generateRandomVisionColors() {
                const redShades = [
                    'rgba(255, 100, 100, 0.3)',
                    'rgba(255, 150, 100, 0.3)',
                    'rgba(255, 120, 120, 0.3)',
                    'rgba(255, 80, 80, 0.3)',
                    'rgba(255, 200, 100, 0.3)'
                ];
                
                this.visionColors = this.guards.map(() => 
                    redShades[Math.floor(Math.random() * redShades.length)]
                );
            }
            
            initializeLevel() {
                const level = this.levels[Math.min(this.currentLevel - 1, this.levels.length - 1)];
                if (!level) return;
                
                this.player = { x: 0, y: 7 };
                this.goal = { x: 7, y: 0 };
                this.guards = level.guards.map(guard => ({
                    ...guard,
                    patrolIndex: 0,
                    moveTimer: 0
                }));
                this.obstacles = [...level.obstacles];
                this.gameState = 'playing';
                this.generateRandomVisionColors();
                
                document.getElementById('currentLevel').textContent = this.currentLevel;
                document.getElementById('levelDisplay').textContent = this.currentLevel;
                
                // Update button states
                document.getElementById('prevBtn').disabled = this.currentLevel <= 1;
                document.getElementById('nextBtn').disabled = this.currentLevel >= this.levels.length;
            }
            
            setupEventListeners() {
                // Character selection
                document.querySelectorAll('.character-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.character-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        this.selectedCharacter = btn.dataset.character;
                        document.getElementById('playerIcon').textContent = this.characterIcons[this.selectedCharacter];
                        this.render();
                    });
                });
                
                // Volume control
                document.getElementById('volumeSlider').addEventListener('input', (e) => {
                    const volume = e.target.value / 100;
                    this.audioManager.setVolume(volume);
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (this.gameState !== 'playing') return;
                    
                    const keyMap = {
                        'ArrowUp': { x: 0, y: -1 },
                        'ArrowDown': { x: 0, y: 1 },
                        'ArrowLeft': { x: -1, y: 0 },
                        'ArrowRight': { x: 1, y: 0 },
                        'w': { x: 0, y: -1 },
                        's': { x: 0, y: 1 },
                        'a': { x: -1, y: 0 },
                        'd': { x: 1, y: 0 }
                    };
                    
                    const move = keyMap[e.key.toLowerCase()];
                    if (move) {
                        e.preventDefault();
                        this.movePlayer(move.x, move.y);
                    }
                });
            }
            
            movePlayer(dx, dy) {
                if (this.gameState !== 'playing') return;
                
                const newX = this.player.x + dx;
                const newY = this.player.y + dy;
                
                if (this.isValidPosition(newX, newY) && !this.isObstacle(newX, newY)) {
                    this.player.x = newX;
                    this.player.y = newY;
                    
                    this.audioManager.playMove();
                    this.checkWinCondition();
                    this.checkDetection();
                    this.render();
                }
            }
            
            isValidPosition(x, y) {
                return x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize;
            }
            
            isObstacle(x, y) {
                return this.obstacles.some(obs => obs.x === x && obs.y === y);
            }
            
            updateGuards() {
                this.guards.forEach(guard => {
                    guard.moveTimer++;
                    
                    if (guard.moveTimer >= 60) {
                        guard.moveTimer = 0;
                        guard.patrolIndex = (guard.patrolIndex + 1) % guard.patrol.length;
                        guard.direction = guard.patrol[guard.patrolIndex];
                    }
                });
            }
            
            getVisionTiles(guard) {
                const visionTiles = [];
                const dir = this.directions[guard.direction];
                
                for (let i = 1; i <= 3; i++) {
                    const x = guard.x + dir.x * i;
                    const y = guard.y + dir.y * i;
                    
                    if (!this.isValidPosition(x, y)) break;
                    
                    visionTiles.push({ x, y });
                    
                    if (this.isObstacle(x, y)) break;
                }
                
                return visionTiles;
            }
            
            checkDetection() {
                for (const guard of this.guards) {
                    const visionTiles = this.getVisionTiles(guard);
                    
                    if (visionTiles.some(tile => tile.x === this.player.x && tile.y === this.player.y)) {
                        this.gameState = 'caught';
                        this.totalAttempts++;
                        this.audioManager.playDetected();
                        this.updateGameStatus();
                        this.updateStats();
                        return;
                    }
                }
            }
            
            checkWinCondition() {
                if (this.player.x === this.goal.x && this.player.y === this.goal.y) {
                    this.gameState = 'won';
                    this.fishCollected++;
                    this.totalAttempts++;
                    this.audioManager.playWin();
                    this.updateGameStatus();
                    this.updateStats();
                }
            }
            
            updateGameStatus() {
                const statusElement = document.getElementById('gameStatus');
                statusElement.className = `status ${this.gameState}`;
                
                switch (this.gameState) {
                    case 'playing':
                        statusElement.textContent = 'Mission Active';
                        break;
                    case 'caught':
                        statusElement.textContent = 'BUSTED! Mission Failed';
                        break;
                    case 'won':
                        statusElement.textContent = 'Mission Accomplished!';
                        break;
                }
            }
            
            updateStats() {
                document.getElementById('fishCount').textContent = this.fishCollected;
                const successRate = this.totalAttempts > 0 ? Math.round((this.fishCollected / this.totalAttempts) * 100) : 0;
                document.getElementById('successRate').textContent = successRate + '%';
            }
            
            render() {
                const board = document.getElementById('gameBoard');
                board.innerHTML = '';
                
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        
                        // Check if this tile is in any guard's vision with random colors
                        const guardIndex = this.guards.findIndex(guard => 
                            this.getVisionTiles(guard).some(vTile => vTile.x === x && vTile.y === y)
                        );
                        
                        if (guardIndex !== -1 && this.gameState === 'playing') {
                            tile.classList.add('vision');
                            tile.style.background = this.visionColors[guardIndex];
                        }
                        
                        if (this.gameState === 'caught' && this.player.x === x && this.player.y === y) {
                            tile.classList.add('detected');
                        }
                        
                        // Add content to tiles
                        if (this.player.x === x && this.player.y === y) {
                            tile.textContent = this.characterIcons[this.selectedCharacter];
                        } else if (this.goal.x === x && this.goal.y === y) {
                            tile.textContent = 'üêü';
                        } else if (this.guards.some(guard => guard.x === x && guard.y === y)) {
                            const guard = this.guards.find(g => g.x === x && g.y === y);
                            const arrows = ['‚Üë', '‚Üí', '‚Üì', '‚Üê'];
                            tile.innerHTML = `üëÆ<div style="font-size: 12px; position: absolute; top: -2px; right: -2px;">${arrows[guard.direction]}</div>`;
                        } else if (this.isObstacle(x, y)) {
                            tile.textContent = 'üì¶';
                            tile.classList.add('obstacle');
                        }
                        
                        board.appendChild(tile);
                    }
                }
            }
            
            startGameLoop() {
                const gameLoop = () => {
                    if (this.gameState === 'playing') {
                        this.updateGuards();
                        this.checkDetection();
                        this.render();
                    }
                    requestAnimationFrame(gameLoop);
                };
                gameLoop();
            }
        }
        
        let game;
        
        function initGame() {
            game = new SnackSnatchGame();
        }
        
        function resetLevel() {
            if (game) {
                game.initializeLevel();
                game.render();
                game.updateGameStatus();
            }
        }
        
        function nextLevel() {
            if (game && game.currentLevel < game.levels.length) {
                game.currentLevel++;
                game.initializeLevel();
                game.render();
                game.updateGameStatus();
            }
        }
        
        function previousLevel() {
            if (game && game.currentLevel > 1) {
                game.currentLevel--;
                game.initializeLevel();
                game.render();
                game.updateGameStatus();
            }
        }
        
        function movePlayer(dx, dy) {
            if (game) {
                game.movePlayer(dx, dy);
            }
        }
        
        function toggleMute() {
            if (game) {
                const isMuted = game.audioManager.toggleMute();
                document.getElementById('muteBtn').textContent = isMuted ? 'üîä Unmute' : 'üîá Mute';
            }
        }
        
        // Initialize the game when the page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>